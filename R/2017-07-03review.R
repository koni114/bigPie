## 2017-07-03 복습 ##
## iris data -> 붓꽃에 대한 데이터

# iris data 변수
# Sepal.Length: 꽃받침 길이.
# Sepal.width : 꽃받침 폭
# Petal.Length: 꽃잎 길이
# Petal.Width : 꽃잎 폭

summary(iris)       # summary() -> data에 대한 간단한 요약을 보여 줌
                    # ex) 최소값, 최대값, 평균. 3분위 수.. 등등

table(iris$Species) # table() -> data를 교차표 형식(테이블 형식)으로 보여 줌.

View(x)             # View()  -> 데이터를 셀형식으로 보여줌.

x1 <- 1             # R은 <- , -> 형식으로 값을 입력할 수 있음(=로도 가능)
2 -> x2

x3 = 1:10           # x3에 1부터 10까지 정수값을 배열로 입력.


(x4 = c(1,5,3,9))   # x4 -> vector
x4[2]               # x4[2] -> vector의 2번째 값

# matrix를 지정할 때, row의 수, col수를 지정 가능
# c1, c2의 matrix는 같음
# 중요한 것은 1,2,3,4,5..가 열방향으로 들어감. -> byrow = T를 통해 행방향으로 변경 가능

c1 <- matrix(1:15, nrow = 5 ) # 행의 수 5
c2 <- matrix(1:15, ncol = 3 ) # 열의 수 3
x5 = matrix(1:15, ncol = 3, byrow=T ) # 값 입력 순서를 행방향 우선으로 변경

x5[2,1] # 행, 열, 면
x5[c(2,4), 3] # c 함수의 값을 불러올 수 도 있음. 내가 지정한 값의 반대값 --> - 붙이면 됨
              # matrix는 데이터 타입이 같아야함. --> 다양한 데이터 타입을 가져오려면 matrixFrame 이라고 함

# 통계 이론
# 데이터에 대한 대표 수치들을 만들겠다. --> 예를들어 중앙값, 평균값 등등..! 보통 평균을 구하라고 하면 산술 평균을 구한다.
# 산술 평균 -> 각 값을 다 더한 뒤, 각 값의 개수로 나눠 준 계산치.
# but, 학점 값은 가중 평균을 사용(가중치에 대한 평균을 계산)

# 예제. 이상치가 존재하는 경우 -> 평균을 구하면 위험하다.
# 이 때 중앙값(median)을 사용하기도 한다.

x1 <-c(1,2,3,4,5,6,7, 1000)
sum(x1)/length(x1) # 데이터는 주로 한자리수 인데, 1000이라는 이상치 때문에 평균이 128.5로 나오게 됨.
mean(x1)           # 직접 평균을 구하지 않아도, mean()를 통해 계산 가능.

# 중앙값 구하는 방법.
# 데이터가 홀수인 경우 -> 중앙 값을 그대로 사용
# 데이터가 짝수인 경우 -> ((n/2)+((n/2)+1))/2 값 사용 (가운데 두 개의 데이터 값의 산술 평균)

median(x1) # 중앙값을 구하는 함수 -> median()
           # **만약 데이터가 정규 분포를 가지고 있다면, 중앙값과 평균값이 일치
           # 의사결정을 할때 데이터의 분산을 보면서 판단.

           # 만약 글자에 대한 평균을 어떻게 구할 것인가? -> 텍스트 마이닝
           # 평균을 만들 수 있는 근거가 있어야 한다.
           # ex) 글자의 빈도 수를 통해? .. 여러가지 아이디어가 나올 수 있음.
           # 흩어진 정도를 따질 때 --> 분산의 개념이 들어감

# 모집단 - 관심의 대상이 되는 모든 사람, 응답 결과, 실험 결과, 측정값들 전체의 집합
# 표본   - 모집단에서 일부 추출 --> 모집단을 대표하는 것. 극단적으로 추출하면 문제가 생김
# 전수조사 VS 표본조사

# 단순 무작위 추출법(simple random sampling)
# 모집단의 각각 요소, 사례들이 동일한 확률로 뽑히도록 하는 추출법을 의미.
# 크게 복원 추출과 비복원 추출로 나눌 수 있음. 주로 복원 추출이 많이 사용 됨 데이터가 부족할 때 주로 복원 추출을 사용하기 때문!

# sampling 할때 sample() 사용 -> sample(data, 뽑을 샘플 수, 복원 여부)

sample(1:45, 6, replace = F )                # replace = T : 복원 추출, replace = F : 비복원 추출.

# 150개의 iris data를 비복원으로 추출하는 경우
ind = sample(1:nrow(iris), 150, replace = F) # 1. random으로 iris data를 뽑기 위해서 총 iris data 의
                                             # 행의 수 중에 무작위로 150개의 행 index vector 를 ind 변수에 저장.
A1 = iris[ind, ]                             # 2. 150개의 iris data 를 추출

# 전체 iris data를 train, test로 나누는 경우.
# --> 기본적으로 모델을 구축하기 위한 train data와, 모델의 성능을 test하기 위한 test data로 나눔.

ind1 = sample(1:nrow(iris), nrow(iris)*0.7, replace= F )
train=iris[ind1,]
test=iris[-ind1,]

# 층화 추출 패키지는 별도로 설치해야 함
# 추측통계학, 기술통계학
# 시각화는 기술통계학의 한 분야

# **기술통계학

# min 최소값,
# 사분위 수 --> (이상 치들이 여기에 들어감. 나중에 일괄적으로 정리를 해야하는데, 제거하기 위해 분위 수를 사용)
# 평균 값과 중앙 값 비교
# 동일한 성향일수록 흩어진 정도가 적다.

# 시각화 방법
# eda(Exploratory data analysis) -> 탐색적 자료 분석
# data를 여러 시각화 방법을 통해 직관적으로 이해하는 방법을 의미
# iris data를 통해 몇가지만 해보자!

# 1. 히스토그램 -> hist()
#

hist(iris$Petal.Length) #구간별로 빈도 수. 단절된 영역이 보임. --> 데이터가 그룹핑이 가능함을 추측 가능

# 2. boxPlot
# 가운데 검은선 -> median
# 위 아래 박스의 범위 1Q ~ 3Q(inter-quatile, 1분위수~ 3분위수)
# 점은 아웃라이어. -> 제거가 필요.
# boxplot을 통해 아웃라이어를 파악할 수 있음.
# boxplot(data)를 이용

boxplot(iris[,1:4])

# y = a + bx

# **정규화와 표준화의 개념

# 표준화(standardization)
# (값 - 평균) / 표준편차
# 평균을 기준으로 얼마나 떨어져 있는지를 알고 싶을 때 사용.
# 두 개의 다른 대상을 비교할 때 각각 표준화를 통해 비교 가능.
# ex) 키와 몸무게를 표준화 시킨 뒤 데이터를 살펴볼때
# 예를 들어 키가 양의 값, 몸무게가 음의 값을 가진다면 키에 비해 말랐음을 알 수 있음.
# 표준화 적용 -> 간극이 줄어드는 효과를 가짐.
# 표준화는 scale()를 통해 적용 가능. -> scale(적용하고 싶은 데이터)
# 표준화 시킬 때 범위로 나누어 주는 경우도 존재

A2 = iris
A2[,1:4] = scale(iris[,1:4])
View(A2) #표준화 적용 후 data 확인


# 양적자료, 질적자료(범주형 자료)
# factor와 numeric을 구분해야 함
# factor -> 단순히 그룹을 지정하기 위해 숫자를 지정한 것. 범주형 데이터
# numeric -> 양적인 의미를 가짐. 계산이 가능.

nlevels(iris$Species) # nlevels() -> factor level의 수를 보여줌.
levels(iris$Species)  # levels()  -> factor level을 구체적으로 보여줌.

# 명목자료 -> 범주를 숫자로 대치 순서자료 -> 순서의 개념을 갖는 질적 자료 + 집단화 자료
# 고유한 성격을 가짐
# ex) 주소, 주민번호

# MASS 라이브러리 안에 survey data 존재
# survey data -> 남녀에대한 기본적인 신체 및 개인 정보가 포함되어 있는 data

library(MASS)
data("survey")
View(survey)
t1 = table(survey$Sex, survey$Smoke) # 성별에 따른 흡연여부 교차표 생성(흡연여부는 크게 4가지로 구성 heavy, never, occas, regul)
prop.table(t1,1)                     # 전체 합계를 기준으로! 1은 행의 합이 1이 되도록, 2는 열단위.

# 막대 그래프를 통해 확인
barplot(t1)

# 줄기- 잎 그래프
stem(t1)



# 각각의 간격 구조를 알아야 함.

# 2장

# 모평균과 표본평균
# 알파벳으로 되어있는것이 표본에 대한 표기법이라고 생각하면 됨
# 잔차(편차)제곱합 , 최소제곱합
# 위의 값들을 왜 나오는가?
# 분류같은 경우는 얼마나 분류를 제대로 하는가,

# 절사 -> 데이터를 평균을 중심으로 양 끝단 데이터를 잘라내는 기법.
# 데이터의 10% 절사 -> 양 side 5%씩을 절사 시키라는 의미

# 예제. 꽃받침과 꽃잎의 길이에 대한 값을 x,y축으로 하여 plot에 찍어보고, 절사 실시.

plot(iris$Petal.Length, iris$Sepal.Length)      # 1. 각 Petal과 Sepal의 길이를 x,y축으로 하여 plotting.
n = round((length(iris$Sepal.Length)*0.1)/2, 0) # 2. 절사 할 갯수 지정
x1 = sort(iris$Sepal.Length)                    # 3. 반드시 데이터 정렬 후 절사 실시!
x2 = x1[(n+1):(length(iris$Sepal.Length)-n)]    # 4. 절삭 실시

# **데이터가 종모양 -> 아주 좋은 모양, but 한쪽으로 치우쳐저 있는 모양이면 좋지 않은 모양

# 최빈값
# 양적자료, 질적자료 다 가능

# 산포(흩어진정도)의 척도
# 분위수 범위 -> 이상치 데이터들을 빼고, 어느정도 흩어져 있는지를 측정할 수 있음.
# 얼마나 흩어져 있는지를 보는 것. 평균에 많이 모여있을수록 동일한 패턴이 존재할 확률이 높다는 것


hist(rnorm(100, mean = 100, sd =3))    # 평균 100, 표준편차가 3인 정규분포를 따르는 data가 100개인 경우,
hist(rnorm(100000, mean = 100, sd= 3)) # 평균 100, 표준편차가 3인 정규분포를 따르는 data가 100000개인 경우,
                                       # -> 데이터의 개수가 많아질수록 점점 좁아진다. 데이터를 인위적으로 만드는 방식
                                       # 만약 뒤에 mean과 sd를 지우면 평균이 0, 분산이1이 되는 것 -> Z


# 데부분의 데이터는 -3 < z < 3 안에 놓인다. 시그마가 1이기 때문에
# 빅데이터를 할 때, 변수가 많다고 해서 반드시 좋은 것은 아니다. 관계성을 찾아내려고 하는 것이기 때문에, 변수가 많아지면,
# 그 변수에 대해서 일일히 설명력을 가져아햔다.

# **상관 관계 분석
# 서로 연관성이 있는 것. -> 빅데이터에서 가장 중요하게 따지는 것.
# 우리가 상관관계가 나오게끔 유도를 해야 함.
# 어떻게 확인?
# 1. plot을 그려 확인 -> 직관적으로 이해 증가, 감소되는 경향을 보임. 중요한 것은 무조건 상관계수가 높은 것이 좋은 것이 아니라,
# 관계성이 존재하는지를  확인하는 것이 중요
# 2. 공분산 확인 -> 두 변수 사이의 관계에 대한 형태, 방향, 그리고 밀접관계의 강도 등을 알 수 있음.
# 0.6이상은 좋은 상관관계를 가진다고 보통 이야기 함

cor(iris[,1:4]) # 상관계수 확인
cor.test(iris$Sepal.Length, iris$Petal.Length) # 상관계수가 존재하는지를 검정
